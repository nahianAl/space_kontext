/**
 * SVG exporter for floor plan export
 * Exports walls, openings, shapes, furniture, and annotations to SVG format
 */

import type { WallGraphStore } from '../store/types';
import type { getWallGraphStore } from '../store/wallGraphStore';
import { useLayerStore } from '../store/layerStore';
import { useShapesStore } from '../store/shapesStore';
import { useDXFBlocksStore } from '../store/dxfBlocksStore';
import { useAnnotationsStore } from '../store/annotationsStore';
import { calculateContentBounds, createSVGTransform, type ExportTransform } from '../utils/exportUtils';
import { metersToMillimeters, metersToPixels } from '@/lib/units/unitsSystem';
import type { ExportOptions } from '../types/export';
import type { Point, WallEdge, WallNode } from '../types/wallGraph';
import type { Shape, LineShape, CircleShape, SquareShape, PolylineShape, ZoneShape, TriangleShape, CurveShape } from '../types/shapes';
import type { Annotation, DimensionAnnotation, TextAnnotation, LeaderAnnotation } from '../types/annotations';

type WallGraphStoreInstance = ReturnType<typeof getWallGraphStore>;

/**
 * Export floor plan to SVG format
 */
export async function exportToSVG(
  options: ExportOptions,
  wallGraphStore: WallGraphStoreInstance
): Promise<Blob> {
  const bounds = calculateContentBounds(options, wallGraphStore);
  if (!bounds) {
    throw new Error('No content to export');
  }

  const transform = createSVGTransform(bounds);
  const widthMM = pixelsToMillimeters(bounds.width);
  const heightMM = pixelsToMillimeters(bounds.height);

  // Build SVG document
  const svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg
  width="${widthMM}mm"
  height="${heightMM}mm"
  viewBox="0 0 ${widthMM} ${heightMM}"
  xmlns="http://www.w3.org/2000/svg"
>
  <!-- Generated by Space KONTEXT -->
  <defs>
    <!-- Layer styles -->
    ${exportLayerStyles()}
  </defs>

  <!-- Walls -->
  ${options.includeWalls ? exportWallsToSVG(transform, wallGraphStore) : ''}

  <!-- Openings -->
  ${options.includeOpenings ? exportOpeningsToSVG(transform, wallGraphStore) : ''}

  <!-- Shapes -->
  ${options.includeShapes ? exportShapesToSVG(transform) : ''}

  <!-- Furniture -->
  ${options.includeFurniture ? exportDXFBlocksToSVG(transform) : ''}

  <!-- Annotations -->
  ${options.includeAnnotations ? exportAnnotationsToSVG(transform) : ''}
</svg>`;

  return new Blob([svg], { type: 'image/svg+xml' });
}

/**
 * Export layer styles as SVG definitions
 */
function exportLayerStyles(): string {
  const layers = useLayerStore.getState().layers;
  return layers.map(layer => {
    return `    <style type="text/css">
      .layer-${layer.id} { stroke: ${layer.color}; fill: none; }
    </style>`;
  }).join('\n');
}

/**
 * Export walls to SVG
 */
function exportWallsToSVG(transform: ExportTransform, wallGraphStore: WallGraphStoreInstance): string {
  const graph = wallGraphStore.getState().graph;
  const walls: string[] = [];

  Object.values(graph.edges).forEach(wall => {
    const startNode = graph.nodes[wall.startNodeId];
    const endNode = graph.nodes[wall.endNodeId];

    if (!startNode || !endNode) {
      return;
    }

    const p1 = transform.transformPoint(startNode.position);
    const p2 = transform.transformPoint(endNode.position);
    const layerClass = `layer-${wall.layer || 'default'}`;

    // Draw centerline
    walls.push(`  <line x1="${p1[0]}" y1="${p1[1]}" x2="${p2[0]}" y2="${p2[1]}" class="${layerClass}" stroke-width="1"/>`);
  });

  return walls.join('\n');
}

/**
 * Export openings to SVG
 */
function exportOpeningsToSVG(transform: ExportTransform, wallGraphStore: WallGraphStoreInstance): string {
  const graph = wallGraphStore.getState().graph;
  const openings: string[] = [];

  Object.values(graph.edges).forEach(wall => {
    const startNode = graph.nodes[wall.startNodeId];
    const endNode = graph.nodes[wall.endNodeId];

    if (!startNode || !endNode) {
      return;
    }

    wall.openings.forEach(opening => {
      const t = opening.position / wall.length;
      const centerX = startNode.position[0] + (endNode.position[0] - startNode.position[0]) * t;
      const centerY = startNode.position[1] + (endNode.position[1] - startNode.position[1]) * t;
      const center = transform.transformPoint([centerX, centerY]);
      const widthMM = metersToMillimeters(opening.width);

      if (opening.type === 'door') {
        // Draw door as rectangle
        openings.push(`  <rect x="${center[0] - widthMM / 2}" y="${center[1]}" width="${widthMM}" height="100" class="layer-${opening.layerId || 'default'}" fill="none" stroke="black" stroke-width="2"/>`);
      } else {
        // Draw window as double-line rectangle
        openings.push(`  <rect x="${center[0] - widthMM / 2}" y="${center[1] - 25}" width="${widthMM}" height="50" class="layer-${opening.layerId || 'default'}" fill="none" stroke="black" stroke-width="2"/>`);
        openings.push(`  <line x1="${center[0] - widthMM / 2}" y1="${center[1] - 12.5}" x2="${center[0] + widthMM / 2}" y2="${center[1] - 12.5}" stroke="black" stroke-width="1"/>`);
        openings.push(`  <line x1="${center[0] - widthMM / 2}" y1="${center[1] + 12.5}" x2="${center[0] + widthMM / 2}" y2="${center[1] + 12.5}" stroke="black" stroke-width="1"/>`);
      }
    });
  });

  return openings.join('\n');
}

/**
 * Export shapes to SVG
 */
function exportShapesToSVG(transform: ExportTransform): string {
  const shapes = useShapesStore.getState().shapes;
  const svgShapes: string[] = [];

  shapes.forEach(shape => {
    const layerClass = `layer-${shape.layerId || 'default'}`;

    switch (shape.type) {
      case 'line':
      case 'arrow':
      case 'guide-line': {
        const s = shape as LineShape;
        const p1 = transform.transformPoint(s.start);
        const p2 = transform.transformPoint(s.end);
        svgShapes.push(`  <line x1="${p1[0]}" y1="${p1[1]}" x2="${p2[0]}" y2="${p2[1]}" class="${layerClass}" stroke-width="1"/>`);
        break;
      }

      case 'circle': {
        const s = shape as CircleShape;
        const center = transform.transformPoint(s.center);
        const radiusMM = transform.toExportUnits(s.radius);
        svgShapes.push(`  <circle cx="${center[0]}" cy="${center[1]}" r="${radiusMM}" class="${layerClass}" stroke-width="1"/>`);
        break;
      }

      case 'square': {
        const s = shape as SquareShape;
        const center = transform.transformPoint(s.center);
        const widthMM = transform.toExportUnits(s.width);
        const heightMM = transform.toExportUnits(s.height);
        const x = center[0] - widthMM / 2;
        const y = center[1] - heightMM / 2;
        const transformAttr = s.rotation ? ` transform="rotate(${s.rotation * 180 / Math.PI} ${center[0]} ${center[1]})"` : '';
        svgShapes.push(`  <rect x="${x}" y="${y}" width="${widthMM}" height="${heightMM}" class="${layerClass}" stroke-width="1"${transformAttr}/>`);
        break;
      }

      case 'polyline':
      case 'zone': {
        const s = shape as PolylineShape | ZoneShape;
        const points = s.points.map(p => transform.transformPoint(p));
        const pointsStr = points.map(p => `${p[0]},${p[1]}`).join(' ');
        const closed = shape.type === 'zone';
        svgShapes.push(`  <polyline points="${pointsStr}" class="${layerClass}" stroke-width="1"${closed ? ' fill="none"' : ''}/>`);
        break;
      }

      case 'triangle': {
        const s = shape as TriangleShape;
        const p1 = transform.transformPoint(s.point1);
        const p2 = transform.transformPoint(s.point2);
        const p3 = transform.transformPoint(s.point3);
        svgShapes.push(`  <polygon points="${p1[0]},${p1[1]} ${p2[0]},${p2[1]} ${p3[0]},${p3[1]}" class="${layerClass}" stroke-width="1"/>`);
        break;
      }

      case 'curve': {
        const s = shape as CurveShape;
        const start = transform.transformPoint(s.start);
        const control = transform.transformPoint(s.control);
        const end = transform.transformPoint(s.end);
        svgShapes.push(`  <path d="M ${start[0]},${start[1]} Q ${control[0]},${control[1]} ${end[0]},${end[1]}" class="${layerClass}" stroke-width="1" fill="none"/>`);
        break;
      }

      case 'image':
        // Images are skipped in SVG export (would need to embed as base64)
        break;
    }
  });

  return svgShapes.join('\n');
}

/**
 * Export DXF blocks to SVG
 */
function exportDXFBlocksToSVG(transform: ExportTransform): string {
  const blocks = useDXFBlocksStore.getState().blocks;
  const svgBlocks: string[] = [];

  blocks.forEach(block => {
    const center = transform.transformPoint([block.x, block.y]);
    // Simplified - in reality, we'd need to render the block's konvaGroupData.shapes
    // For now, just place a placeholder rectangle
    svgBlocks.push(`  <g transform="translate(${center[0]},${center[1]}) rotate(${block.rotation}) scale(${block.scaleX},${block.scaleY})">
    <rect x="-50" y="-50" width="100" height="100" fill="none" stroke="gray" stroke-width="1"/>
  </g>`);
  });

  return svgBlocks.join('\n');
}

/**
 * Export annotations to SVG
 */
function exportAnnotationsToSVG(transform: ExportTransform): string {
  const annotations = Array.from(useAnnotationsStore.getState().annotations.values());
  const svgAnnotations: string[] = [];

  annotations.forEach(annotation => {
    const layerClass = `layer-${annotation.layer || 'annotations'}`;

    switch (annotation.type) {
      case 'dimension': {
        const dim = annotation as DimensionAnnotation;
        const p1 = transform.transformPoint(dim.startPoint);
        const p2 = transform.transformPoint(dim.endPoint);
        svgAnnotations.push(`  <line x1="${p1[0]}" y1="${p1[1]}" x2="${p2[0]}" y2="${p2[1]}" class="${layerClass}" stroke-width="1"/>`);
        // Add dimension text (simplified)
        const midX = (p1[0] + p2[0]) / 2;
        const midY = (p1[1] + p2[1]) / 2;
        const distance = Math.sqrt(Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2));
        svgAnnotations.push(`  <text x="${midX}" y="${midY}" class="${layerClass}" font-size="10">${distance.toFixed(2)}</text>`);
        break;
      }

      case 'text': {
        const txt = annotation as TextAnnotation;
        const pos = transform.transformPoint(txt.position);
        svgAnnotations.push(`  <text x="${pos[0]}" y="${pos[1]}" class="${layerClass}" font-size="${txt.fontSize || 10}" fill="${txt.textColor || 'black'}">${escapeXml(txt.content)}</text>`);
        break;
      }

      case 'leader': {
        const leader = annotation as LeaderAnnotation;
        const elemPt = transform.transformPoint(leader.elementPoint);
        const textPt = transform.transformPoint(leader.textPoint);
        svgAnnotations.push(`  <line x1="${elemPt[0]}" y1="${elemPt[1]}" x2="${textPt[0]}" y2="${textPt[1]}" class="${layerClass}" stroke-width="1"/>`);
        svgAnnotations.push(`  <text x="${textPt[0]}" y="${textPt[1]}" class="${layerClass}" font-size="12">${escapeXml(leader.text || '')}</text>`);
        break;
      }
    }
  });

  return svgAnnotations.join('\n');
}

/**
 * Escape XML special characters
 */
function escapeXml(text: string): string {
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;');
}

/**
 * Convert pixels to millimeters for SVG export
 */
function pixelsToMillimeters(pixels: number): number {
  const meters = pixels / 100; // PIXELS_PER_METER = 100
  return metersToMillimeters(meters);
}

